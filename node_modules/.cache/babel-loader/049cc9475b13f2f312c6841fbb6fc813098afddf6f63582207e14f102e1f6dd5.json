{"ast":null,"code":"'use client';\n\nimport { useRef, useCallback, useMemo } from 'react';\nimport getWidth from 'dom-lib/getWidth';\nimport getHeight from 'dom-lib/getHeight';\nimport getOffset from 'dom-lib/getOffset';\nimport { SCROLLBAR_WIDTH } from '../constants';\nimport { ResizeObserver } from '@juggle/resize-observer';\nimport useMount from './useMount';\nimport useUpdateLayoutEffect from './useUpdateLayoutEffect';\nimport useIntersectionObserver from './useIntersectionObserver';\nimport isNumberOrTrue from './isNumberOrTrue';\nimport debounce from 'lodash/debounce';\n/**\n * The dimension information of the table,\n * including the height, width, scrollable distance and the coordinates of the scroll handle, etc.\n * @param props\n * @returns\n */\nvar useTableDimension = function useTableDimension(props) {\n  var data = props.data,\n    rowHeight = props.rowHeight,\n    tableRef = props.tableRef,\n    headerWrapperRef = props.headerWrapperRef,\n    prefix = props.prefix,\n    widthProp = props.width,\n    affixHeader = props.affixHeader,\n    affixHorizontalScrollbar = props.affixHorizontalScrollbar,\n    headerHeight = props.headerHeight,\n    heightProp = props.height,\n    autoHeightProp = props.autoHeight,\n    minHeight = props.minHeight,\n    maxHeight = props.maxHeight,\n    fillHeight = props.fillHeight,\n    children = props.children,\n    expandedRowKeys = props.expandedRowKeys,\n    showHeader = props.showHeader,\n    bordered = props.bordered,\n    onTableResizeChange = props.onTableResizeChange,\n    onTableScroll = props.onTableScroll;\n  var contentHeight = useRef(0);\n  var contentWidth = useRef(0);\n  var minScrollY = useRef(0);\n  var scrollY = useRef(0);\n  var scrollX = useRef(0);\n  var minScrollX = useRef(0);\n  var tableWidth = useRef(widthProp || 0);\n  var tableHeight = useRef(heightProp || 0);\n  var columnCount = useRef(0);\n  var resizeObserver = useRef();\n  var containerResizeObserver = useRef();\n  var headerOffset = useRef(null);\n  var tableOffset = useRef(null);\n  var autoHeight = useMemo(function () {\n    return autoHeightProp && !maxHeight;\n  }, [autoHeightProp, maxHeight]);\n  var getRowHeight = useCallback(function (rowData) {\n    return typeof rowHeight === 'function' ? rowHeight(rowData) : rowHeight;\n  }, [rowHeight]);\n  var calculateTableContextHeight = useCallback(function () {\n    var _table$querySelectorA;\n    var prevContentHeight = contentHeight.current;\n    var table = tableRef === null || tableRef === void 0 ? void 0 : tableRef.current;\n    var rows = (table === null || table === void 0 ? void 0 : table.querySelectorAll(\".\" + (prefix === null || prefix === void 0 ? void 0 : prefix('row')))) || [];\n    var virtualized = (table === null || table === void 0 ? void 0 : (_table$querySelectorA = table.querySelectorAll('.virtualized')) === null || _table$querySelectorA === void 0 ? void 0 : _table$querySelectorA.length) > 0;\n    var nextContentHeight = rows.length ? Array.from(rows).map(function (row, index) {\n      return getHeight(row) || getRowHeight(data === null || data === void 0 ? void 0 : data[index]);\n    }).reduce(function (x, y) {\n      return x + y;\n    }) : 0;\n\n    // After setting the affixHeader property, the height of the two headers should be subtracted.\n    contentHeight.current = Math.round(nextContentHeight - (affixHeader ? headerHeight * 2 : headerHeight));\n\n    // Whether to show the horizontal scroll bar\n    var hasHorizontalScrollbar = contentWidth.current > tableWidth.current;\n\n    // The height of the table content area should be added to the height occupied by the horizontal scroll bar when autoHeight is set.\n    if (autoHeight && hasHorizontalScrollbar) {\n      contentHeight.current += SCROLLBAR_WIDTH;\n    }\n    var height = fillHeight ? tableHeight.current : Math.max(heightProp, maxHeight || 0);\n    var tableBodyHeight = showHeader ? height - headerHeight : height;\n    if (!autoHeight) {\n      /**\n       *  The purpose of subtracting SCROLLBAR_WIDTH is to keep the scroll bar from blocking the content part.\n       *  But it will only be calculated when there is a horizontal scroll bar (contentWidth > tableWidth).\n       */\n      minScrollY.current = -(nextContentHeight - height) - (hasHorizontalScrollbar ? SCROLLBAR_WIDTH : 0);\n    }\n\n    // If the height of the content area is less than the height of the table, the vertical scroll bar is reset.\n    if (nextContentHeight < height) {\n      onTableScroll === null || onTableScroll === void 0 ? void 0 : onTableScroll({\n        y: 0\n      });\n    }\n    var currentScrollTop = Math.abs(scrollY.current);\n\n    // When Table is set to virtualized, the logic will be entered every time the wheel event is\n    // triggered to avoid resetting the scroll bar after scrolling to the bottom, so add the SCROLLBAR_WIDTH value.\n    var maxScrollTop = nextContentHeight + SCROLLBAR_WIDTH - tableBodyHeight;\n\n    // If the top value of the current scroll is greater than the scrollable range,\n    // keep the vertical scroll bar at the bottom.\n    if (maxScrollTop > 0 && currentScrollTop > maxScrollTop) {\n      if (virtualized) {\n        onTableScroll === null || onTableScroll === void 0 ? void 0 : onTableScroll({\n          y: ((data === null || data === void 0 ? void 0 : data.length) || 0) * getRowHeight() - tableBodyHeight\n        });\n      } else {\n        onTableScroll === null || onTableScroll === void 0 ? void 0 : onTableScroll({\n          y: maxScrollTop\n        });\n      }\n    }\n    if (prevContentHeight !== contentHeight.current) {\n      onTableResizeChange === null || onTableResizeChange === void 0 ? void 0 : onTableResizeChange(prevContentHeight, 'bodyHeightChanged');\n    }\n  }, [tableRef, prefix, affixHeader, headerHeight, autoHeight, maxHeight, fillHeight, heightProp, showHeader, getRowHeight, data, onTableScroll, onTableResizeChange]);\n  var setOffsetByAffix = useCallback(function () {\n    var headerNode = headerWrapperRef === null || headerWrapperRef === void 0 ? void 0 : headerWrapperRef.current;\n    if (isNumberOrTrue(affixHeader) && headerNode) {\n      headerOffset.current = getOffset(headerNode);\n    }\n    if (isNumberOrTrue(affixHorizontalScrollbar) && tableRef !== null && tableRef !== void 0 && tableRef.current) {\n      tableOffset.current = getOffset(tableRef === null || tableRef === void 0 ? void 0 : tableRef.current);\n    }\n  }, [affixHeader, affixHorizontalScrollbar, headerWrapperRef, tableRef]);\n  var calculateTableContentWidth = useCallback(function () {\n    var prevWidth = contentWidth.current;\n    var prevColumnCount = columnCount.current;\n    var table = tableRef === null || tableRef === void 0 ? void 0 : tableRef.current;\n    var row = table === null || table === void 0 ? void 0 : table.querySelector(\".\" + prefix('row') + \":not(.virtualized)\");\n    var nextContentWidth = row ? getWidth(row) : 0;\n\n    // Whether to show the horizontal scroll bar\n    var hasHorizontalScrollbar = contentWidth.current > tableWidth.current;\n    var scrollbarWidth = hasHorizontalScrollbar ? 0 : SCROLLBAR_WIDTH;\n    contentWidth.current = nextContentWidth - (autoHeight ? scrollbarWidth : 0);\n    columnCount.current = (row === null || row === void 0 ? void 0 : row.querySelectorAll(\".\" + prefix('cell')).length) || 0;\n\n    // The value of SCROLLBAR_WIDTH is subtracted so that the scroll bar does not block the content part.\n    // There is no vertical scroll bar after autoHeight.\n    var minScrollWidth = -(nextContentWidth - tableWidth.current) - (autoHeight ? 0 : scrollbarWidth);\n    if (minScrollX.current !== minScrollWidth) {\n      minScrollX.current = minScrollWidth;\n      if (scrollX.current < minScrollWidth) {\n        // fix: 405#issuecomment-1464831646\n        scrollX.current = minScrollWidth;\n      }\n    }\n\n    /**\n     * If the width of the content area and the number of columns change,\n     * the horizontal scroll bar is reset.\n     * fix: https://github.com/rsuite/rsuite/issues/2039\n     */\n    if (prevWidth > 0 && prevWidth !== contentWidth.current || prevColumnCount > 0 && prevColumnCount !== columnCount.current) {\n      onTableResizeChange === null || onTableResizeChange === void 0 ? void 0 : onTableResizeChange(prevWidth, 'bodyWidthChanged');\n    }\n  }, [autoHeight, onTableResizeChange, prefix, tableRef]);\n  var calculateTableWidth = useCallback(function (nextWidth) {\n    var prevWidth = tableWidth.current;\n    if (tableRef !== null && tableRef !== void 0 && tableRef.current) {\n      tableWidth.current = nextWidth || getWidth(tableRef === null || tableRef === void 0 ? void 0 : tableRef.current);\n    }\n    if (prevWidth && prevWidth !== tableWidth.current) {\n      scrollX.current = 0;\n      onTableResizeChange === null || onTableResizeChange === void 0 ? void 0 : onTableResizeChange(prevWidth, 'widthChanged');\n    }\n    setOffsetByAffix();\n  }, [onTableResizeChange, setOffsetByAffix, tableRef]);\n  var calculateTableHeight = useCallback(function (nextHeight) {\n    var prevHeight = tableHeight.current;\n    if (nextHeight) {\n      tableHeight.current = nextHeight;\n    } else if (tableRef !== null && tableRef !== void 0 && tableRef.current) {\n      tableHeight.current = getHeight(tableRef.current.parentNode);\n    }\n    if (prevHeight && prevHeight !== tableHeight.current) {\n      onTableResizeChange === null || onTableResizeChange === void 0 ? void 0 : onTableResizeChange(prevHeight, 'heightChanged');\n    }\n  }, [onTableResizeChange, tableRef]);\n  useMount(function () {\n    var _tableRef$current;\n    calculateTableContextHeight();\n    calculateTableContentWidth();\n    calculateTableWidth();\n    calculateTableHeight();\n    setOffsetByAffix();\n    containerResizeObserver.current = new ResizeObserver(function (entries) {\n      calculateTableHeight(entries[0].contentRect.height);\n    });\n    containerResizeObserver.current.observe(tableRef === null || tableRef === void 0 ? void 0 : (_tableRef$current = tableRef.current) === null || _tableRef$current === void 0 ? void 0 : _tableRef$current.parentNode);\n    var changeTableWidthWhenResize = debounce(function (entries) {\n      var width = entries[0].contentRect.width;\n      // bordered table width is 1px larger than the container width. fix: #405 #404\n      var widthWithBorder = width + 2;\n      calculateTableWidth(bordered ? widthWithBorder : width);\n    }, 20);\n    resizeObserver.current = new ResizeObserver(changeTableWidthWhenResize);\n    resizeObserver.current.observe(tableRef === null || tableRef === void 0 ? void 0 : tableRef.current);\n    return function () {\n      var _resizeObserver$curre, _containerResizeObser;\n      (_resizeObserver$curre = resizeObserver.current) === null || _resizeObserver$curre === void 0 ? void 0 : _resizeObserver$curre.disconnect();\n      (_containerResizeObser = containerResizeObserver.current) === null || _containerResizeObser === void 0 ? void 0 : _containerResizeObser.disconnect();\n    };\n  });\n  useUpdateLayoutEffect(function () {\n    calculateTableHeight();\n    calculateTableContextHeight();\n  }, [fillHeight]);\n  useUpdateLayoutEffect(function () {\n    calculateTableWidth();\n    calculateTableContentWidth();\n    calculateTableContextHeight();\n  }, [data, heightProp, contentHeight.current, expandedRowKeys, children, calculateTableContextHeight, calculateTableContentWidth]);\n  var isVisible = useIntersectionObserver(tableRef);\n  useUpdateLayoutEffect(function () {\n    // When the table is visible, the width of the table is recalculated.\n    // fix: https://github.com/rsuite/rsuite/issues/397\n    if (isVisible) {\n      calculateTableWidth();\n      calculateTableContentWidth();\n    }\n  }, [isVisible]);\n  var setScrollY = useCallback(function (value) {\n    scrollY.current = value;\n  }, []);\n  var setScrollX = useCallback(function (value) {\n    scrollX.current = value;\n  }, []);\n  var getTableHeight = function getTableHeight() {\n    if (fillHeight) {\n      return tableHeight.current;\n    }\n\n    // When the data is empty and autoHeight is set, use the default height to display the empty state.\n    if ((data === null || data === void 0 ? void 0 : data.length) === 0 && autoHeight) {\n      return heightProp;\n    }\n    var height = autoHeightProp ? headerHeight + contentHeight.current : heightProp;\n    if (maxHeight && height > maxHeight) {\n      return maxHeight;\n    }\n    if (minHeight && height < minHeight) {\n      return minHeight;\n    }\n    return height;\n  };\n  return {\n    contentHeight: contentHeight,\n    contentWidth: contentWidth,\n    minScrollY: minScrollY,\n    minScrollX: minScrollX,\n    scrollY: scrollY,\n    scrollX: scrollX,\n    tableWidth: tableWidth,\n    headerOffset: headerOffset,\n    tableOffset: tableOffset,\n    getTableHeight: getTableHeight,\n    setScrollY: setScrollY,\n    setScrollX: setScrollX\n  };\n};\nexport default useTableDimension;","map":{"version":3,"names":["useRef","useCallback","useMemo","getWidth","getHeight","getOffset","SCROLLBAR_WIDTH","ResizeObserver","useMount","useUpdateLayoutEffect","useIntersectionObserver","isNumberOrTrue","debounce","useTableDimension","props","data","rowHeight","tableRef","headerWrapperRef","prefix","widthProp","width","affixHeader","affixHorizontalScrollbar","headerHeight","heightProp","height","autoHeightProp","autoHeight","minHeight","maxHeight","fillHeight","children","expandedRowKeys","showHeader","bordered","onTableResizeChange","onTableScroll","contentHeight","contentWidth","minScrollY","scrollY","scrollX","minScrollX","tableWidth","tableHeight","columnCount","resizeObserver","containerResizeObserver","headerOffset","tableOffset","getRowHeight","rowData","calculateTableContextHeight","_table$querySelectorA","prevContentHeight","current","table","rows","querySelectorAll","virtualized","length","nextContentHeight","Array","from","map","row","index","reduce","x","y","Math","round","hasHorizontalScrollbar","max","tableBodyHeight","currentScrollTop","abs","maxScrollTop","setOffsetByAffix","headerNode","calculateTableContentWidth","prevWidth","prevColumnCount","querySelector","nextContentWidth","scrollbarWidth","minScrollWidth","calculateTableWidth","nextWidth","calculateTableHeight","nextHeight","prevHeight","parentNode","_tableRef$current","entries","contentRect","observe","changeTableWidthWhenResize","widthWithBorder","_resizeObserver$curre","_containerResizeObser","disconnect","isVisible","setScrollY","value","setScrollX","getTableHeight"],"sources":["C:/Users/lenovo/OneDrive/Documents/local project/platfoorm45_technical_challenge/node_modules/rsuite-table/es/utils/useTableDimension.js"],"sourcesContent":["'use client';\nimport { useRef, useCallback, useMemo } from 'react';\nimport getWidth from 'dom-lib/getWidth';\nimport getHeight from 'dom-lib/getHeight';\nimport getOffset from 'dom-lib/getOffset';\nimport { SCROLLBAR_WIDTH } from '../constants';\nimport { ResizeObserver } from '@juggle/resize-observer';\nimport useMount from './useMount';\nimport useUpdateLayoutEffect from './useUpdateLayoutEffect';\nimport useIntersectionObserver from './useIntersectionObserver';\nimport isNumberOrTrue from './isNumberOrTrue';\nimport debounce from 'lodash/debounce';\n/**\n * The dimension information of the table,\n * including the height, width, scrollable distance and the coordinates of the scroll handle, etc.\n * @param props\n * @returns\n */\nvar useTableDimension = function useTableDimension(props) {\n  var data = props.data,\n    rowHeight = props.rowHeight,\n    tableRef = props.tableRef,\n    headerWrapperRef = props.headerWrapperRef,\n    prefix = props.prefix,\n    widthProp = props.width,\n    affixHeader = props.affixHeader,\n    affixHorizontalScrollbar = props.affixHorizontalScrollbar,\n    headerHeight = props.headerHeight,\n    heightProp = props.height,\n    autoHeightProp = props.autoHeight,\n    minHeight = props.minHeight,\n    maxHeight = props.maxHeight,\n    fillHeight = props.fillHeight,\n    children = props.children,\n    expandedRowKeys = props.expandedRowKeys,\n    showHeader = props.showHeader,\n    bordered = props.bordered,\n    onTableResizeChange = props.onTableResizeChange,\n    onTableScroll = props.onTableScroll;\n  var contentHeight = useRef(0);\n  var contentWidth = useRef(0);\n  var minScrollY = useRef(0);\n  var scrollY = useRef(0);\n  var scrollX = useRef(0);\n  var minScrollX = useRef(0);\n  var tableWidth = useRef(widthProp || 0);\n  var tableHeight = useRef(heightProp || 0);\n  var columnCount = useRef(0);\n  var resizeObserver = useRef();\n  var containerResizeObserver = useRef();\n  var headerOffset = useRef(null);\n  var tableOffset = useRef(null);\n  var autoHeight = useMemo(function () {\n    return autoHeightProp && !maxHeight;\n  }, [autoHeightProp, maxHeight]);\n  var getRowHeight = useCallback(function (rowData) {\n    return typeof rowHeight === 'function' ? rowHeight(rowData) : rowHeight;\n  }, [rowHeight]);\n  var calculateTableContextHeight = useCallback(function () {\n    var _table$querySelectorA;\n    var prevContentHeight = contentHeight.current;\n    var table = tableRef === null || tableRef === void 0 ? void 0 : tableRef.current;\n    var rows = (table === null || table === void 0 ? void 0 : table.querySelectorAll(\".\" + (prefix === null || prefix === void 0 ? void 0 : prefix('row')))) || [];\n    var virtualized = (table === null || table === void 0 ? void 0 : (_table$querySelectorA = table.querySelectorAll('.virtualized')) === null || _table$querySelectorA === void 0 ? void 0 : _table$querySelectorA.length) > 0;\n    var nextContentHeight = rows.length ? Array.from(rows).map(function (row, index) {\n      return getHeight(row) || getRowHeight(data === null || data === void 0 ? void 0 : data[index]);\n    }).reduce(function (x, y) {\n      return x + y;\n    }) : 0;\n\n    // After setting the affixHeader property, the height of the two headers should be subtracted.\n    contentHeight.current = Math.round(nextContentHeight - (affixHeader ? headerHeight * 2 : headerHeight));\n\n    // Whether to show the horizontal scroll bar\n    var hasHorizontalScrollbar = contentWidth.current > tableWidth.current;\n\n    // The height of the table content area should be added to the height occupied by the horizontal scroll bar when autoHeight is set.\n    if (autoHeight && hasHorizontalScrollbar) {\n      contentHeight.current += SCROLLBAR_WIDTH;\n    }\n    var height = fillHeight ? tableHeight.current : Math.max(heightProp, maxHeight || 0);\n    var tableBodyHeight = showHeader ? height - headerHeight : height;\n    if (!autoHeight) {\n      /**\n       *  The purpose of subtracting SCROLLBAR_WIDTH is to keep the scroll bar from blocking the content part.\n       *  But it will only be calculated when there is a horizontal scroll bar (contentWidth > tableWidth).\n       */\n      minScrollY.current = -(nextContentHeight - height) - (hasHorizontalScrollbar ? SCROLLBAR_WIDTH : 0);\n    }\n\n    // If the height of the content area is less than the height of the table, the vertical scroll bar is reset.\n    if (nextContentHeight < height) {\n      onTableScroll === null || onTableScroll === void 0 ? void 0 : onTableScroll({\n        y: 0\n      });\n    }\n    var currentScrollTop = Math.abs(scrollY.current);\n\n    // When Table is set to virtualized, the logic will be entered every time the wheel event is\n    // triggered to avoid resetting the scroll bar after scrolling to the bottom, so add the SCROLLBAR_WIDTH value.\n    var maxScrollTop = nextContentHeight + SCROLLBAR_WIDTH - tableBodyHeight;\n\n    // If the top value of the current scroll is greater than the scrollable range,\n    // keep the vertical scroll bar at the bottom.\n    if (maxScrollTop > 0 && currentScrollTop > maxScrollTop) {\n      if (virtualized) {\n        onTableScroll === null || onTableScroll === void 0 ? void 0 : onTableScroll({\n          y: ((data === null || data === void 0 ? void 0 : data.length) || 0) * getRowHeight() - tableBodyHeight\n        });\n      } else {\n        onTableScroll === null || onTableScroll === void 0 ? void 0 : onTableScroll({\n          y: maxScrollTop\n        });\n      }\n    }\n    if (prevContentHeight !== contentHeight.current) {\n      onTableResizeChange === null || onTableResizeChange === void 0 ? void 0 : onTableResizeChange(prevContentHeight, 'bodyHeightChanged');\n    }\n  }, [tableRef, prefix, affixHeader, headerHeight, autoHeight, maxHeight, fillHeight, heightProp, showHeader, getRowHeight, data, onTableScroll, onTableResizeChange]);\n  var setOffsetByAffix = useCallback(function () {\n    var headerNode = headerWrapperRef === null || headerWrapperRef === void 0 ? void 0 : headerWrapperRef.current;\n    if (isNumberOrTrue(affixHeader) && headerNode) {\n      headerOffset.current = getOffset(headerNode);\n    }\n    if (isNumberOrTrue(affixHorizontalScrollbar) && tableRef !== null && tableRef !== void 0 && tableRef.current) {\n      tableOffset.current = getOffset(tableRef === null || tableRef === void 0 ? void 0 : tableRef.current);\n    }\n  }, [affixHeader, affixHorizontalScrollbar, headerWrapperRef, tableRef]);\n  var calculateTableContentWidth = useCallback(function () {\n    var prevWidth = contentWidth.current;\n    var prevColumnCount = columnCount.current;\n    var table = tableRef === null || tableRef === void 0 ? void 0 : tableRef.current;\n    var row = table === null || table === void 0 ? void 0 : table.querySelector(\".\" + prefix('row') + \":not(.virtualized)\");\n    var nextContentWidth = row ? getWidth(row) : 0;\n\n    // Whether to show the horizontal scroll bar\n    var hasHorizontalScrollbar = contentWidth.current > tableWidth.current;\n    var scrollbarWidth = hasHorizontalScrollbar ? 0 : SCROLLBAR_WIDTH;\n    contentWidth.current = nextContentWidth - (autoHeight ? scrollbarWidth : 0);\n    columnCount.current = (row === null || row === void 0 ? void 0 : row.querySelectorAll(\".\" + prefix('cell')).length) || 0;\n\n    // The value of SCROLLBAR_WIDTH is subtracted so that the scroll bar does not block the content part.\n    // There is no vertical scroll bar after autoHeight.\n    var minScrollWidth = -(nextContentWidth - tableWidth.current) - (autoHeight ? 0 : scrollbarWidth);\n    if (minScrollX.current !== minScrollWidth) {\n      minScrollX.current = minScrollWidth;\n      if (scrollX.current < minScrollWidth) {\n        // fix: 405#issuecomment-1464831646\n        scrollX.current = minScrollWidth;\n      }\n    }\n\n    /**\n     * If the width of the content area and the number of columns change,\n     * the horizontal scroll bar is reset.\n     * fix: https://github.com/rsuite/rsuite/issues/2039\n     */\n    if (prevWidth > 0 && prevWidth !== contentWidth.current || prevColumnCount > 0 && prevColumnCount !== columnCount.current) {\n      onTableResizeChange === null || onTableResizeChange === void 0 ? void 0 : onTableResizeChange(prevWidth, 'bodyWidthChanged');\n    }\n  }, [autoHeight, onTableResizeChange, prefix, tableRef]);\n  var calculateTableWidth = useCallback(function (nextWidth) {\n    var prevWidth = tableWidth.current;\n    if (tableRef !== null && tableRef !== void 0 && tableRef.current) {\n      tableWidth.current = nextWidth || getWidth(tableRef === null || tableRef === void 0 ? void 0 : tableRef.current);\n    }\n    if (prevWidth && prevWidth !== tableWidth.current) {\n      scrollX.current = 0;\n      onTableResizeChange === null || onTableResizeChange === void 0 ? void 0 : onTableResizeChange(prevWidth, 'widthChanged');\n    }\n    setOffsetByAffix();\n  }, [onTableResizeChange, setOffsetByAffix, tableRef]);\n  var calculateTableHeight = useCallback(function (nextHeight) {\n    var prevHeight = tableHeight.current;\n    if (nextHeight) {\n      tableHeight.current = nextHeight;\n    } else if (tableRef !== null && tableRef !== void 0 && tableRef.current) {\n      tableHeight.current = getHeight(tableRef.current.parentNode);\n    }\n    if (prevHeight && prevHeight !== tableHeight.current) {\n      onTableResizeChange === null || onTableResizeChange === void 0 ? void 0 : onTableResizeChange(prevHeight, 'heightChanged');\n    }\n  }, [onTableResizeChange, tableRef]);\n  useMount(function () {\n    var _tableRef$current;\n    calculateTableContextHeight();\n    calculateTableContentWidth();\n    calculateTableWidth();\n    calculateTableHeight();\n    setOffsetByAffix();\n    containerResizeObserver.current = new ResizeObserver(function (entries) {\n      calculateTableHeight(entries[0].contentRect.height);\n    });\n    containerResizeObserver.current.observe(tableRef === null || tableRef === void 0 ? void 0 : (_tableRef$current = tableRef.current) === null || _tableRef$current === void 0 ? void 0 : _tableRef$current.parentNode);\n    var changeTableWidthWhenResize = debounce(function (entries) {\n      var width = entries[0].contentRect.width;\n      // bordered table width is 1px larger than the container width. fix: #405 #404\n      var widthWithBorder = width + 2;\n      calculateTableWidth(bordered ? widthWithBorder : width);\n    }, 20);\n    resizeObserver.current = new ResizeObserver(changeTableWidthWhenResize);\n    resizeObserver.current.observe(tableRef === null || tableRef === void 0 ? void 0 : tableRef.current);\n    return function () {\n      var _resizeObserver$curre, _containerResizeObser;\n      (_resizeObserver$curre = resizeObserver.current) === null || _resizeObserver$curre === void 0 ? void 0 : _resizeObserver$curre.disconnect();\n      (_containerResizeObser = containerResizeObserver.current) === null || _containerResizeObser === void 0 ? void 0 : _containerResizeObser.disconnect();\n    };\n  });\n  useUpdateLayoutEffect(function () {\n    calculateTableHeight();\n    calculateTableContextHeight();\n  }, [fillHeight]);\n  useUpdateLayoutEffect(function () {\n    calculateTableWidth();\n    calculateTableContentWidth();\n    calculateTableContextHeight();\n  }, [data, heightProp, contentHeight.current, expandedRowKeys, children, calculateTableContextHeight, calculateTableContentWidth]);\n  var isVisible = useIntersectionObserver(tableRef);\n  useUpdateLayoutEffect(function () {\n    // When the table is visible, the width of the table is recalculated.\n    // fix: https://github.com/rsuite/rsuite/issues/397\n    if (isVisible) {\n      calculateTableWidth();\n      calculateTableContentWidth();\n    }\n  }, [isVisible]);\n  var setScrollY = useCallback(function (value) {\n    scrollY.current = value;\n  }, []);\n  var setScrollX = useCallback(function (value) {\n    scrollX.current = value;\n  }, []);\n  var getTableHeight = function getTableHeight() {\n    if (fillHeight) {\n      return tableHeight.current;\n    }\n\n    // When the data is empty and autoHeight is set, use the default height to display the empty state.\n    if ((data === null || data === void 0 ? void 0 : data.length) === 0 && autoHeight) {\n      return heightProp;\n    }\n    var height = autoHeightProp ? headerHeight + contentHeight.current : heightProp;\n    if (maxHeight && height > maxHeight) {\n      return maxHeight;\n    }\n    if (minHeight && height < minHeight) {\n      return minHeight;\n    }\n    return height;\n  };\n  return {\n    contentHeight: contentHeight,\n    contentWidth: contentWidth,\n    minScrollY: minScrollY,\n    minScrollX: minScrollX,\n    scrollY: scrollY,\n    scrollX: scrollX,\n    tableWidth: tableWidth,\n    headerOffset: headerOffset,\n    tableOffset: tableOffset,\n    getTableHeight: getTableHeight,\n    setScrollY: setScrollY,\n    setScrollX: setScrollX\n  };\n};\nexport default useTableDimension;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}