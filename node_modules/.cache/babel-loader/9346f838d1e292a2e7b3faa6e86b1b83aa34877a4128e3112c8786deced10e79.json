{"ast":null,"code":"'use client';\n\nimport { useState, useCallback, useRef } from 'react';\nimport getHeight from 'dom-lib/getHeight';\nimport useUpdateLayoutEffect from './useUpdateLayoutEffect';\nimport useMount from './useMount';\nimport isEmpty from 'lodash/isEmpty';\nimport defer from './defer';\n/**\n * The row information of the table, get the DOM of all rows, and summarize the row height.\n * @param props\n * @returns\n */\nvar useTableRows = function useTableRows(props) {\n  var prefix = props.prefix,\n    wordWrap = props.wordWrap,\n    data = props.data,\n    expandedRowKeys = props.expandedRowKeys;\n  var _useState = useState([]),\n    tableRowsMaxHeight = _useState[0],\n    setTableRowsMaxHeight = _useState[1];\n  var tableRows = useRef({});\n  var bindTableRowsRef = function bindTableRowsRef(index, rowData) {\n    return function (ref) {\n      if (ref) {\n        tableRows.current[index] = [ref, rowData];\n      }\n    };\n  };\n  var calculateRowMaxHeight = useCallback(function () {\n    if (wordWrap) {\n      var nextTableRowsMaxHeight = [];\n      var curTableRows = Object.values(tableRows.current);\n      for (var i = 0; i < curTableRows.length; i++) {\n        var _curTableRows$i = curTableRows[i],\n          row = _curTableRows$i[0];\n        if (row) {\n          var cells = row.querySelectorAll(\".\" + prefix('cell-wrap')) || [];\n          var cellArray = Array.from(cells);\n          var maxHeight = 0;\n          for (var j = 0; j < cellArray.length; j++) {\n            var cell = cellArray[j];\n            var h = getHeight(cell);\n            maxHeight = Math.max(maxHeight, h);\n          }\n          nextTableRowsMaxHeight.push(maxHeight);\n        }\n      }\n\n      // Can't perform a React state update on an unmounted component\n      if (!isEmpty(tableRows.current)) {\n        setTableRowsMaxHeight(nextTableRowsMaxHeight);\n      }\n    }\n  }, [prefix, wordWrap]);\n  useMount(function () {\n    defer(calculateRowMaxHeight);\n  });\n  useUpdateLayoutEffect(function () {\n    /**\n     * After the data is updated, the height of the cell DOM needs to be re-acquired,\n     * and what is often obtained is not the latest DOM that has been rendered.\n     * So use `defer` to delay obtaining the height of the cell DOM.\n     * TODO: To be improved\n     */\n    defer(calculateRowMaxHeight);\n  }, [data, expandedRowKeys]);\n  return {\n    bindTableRowsRef: bindTableRowsRef,\n    tableRowsMaxHeight: tableRowsMaxHeight,\n    tableRows: tableRows\n  };\n};\nexport default useTableRows;","map":{"version":3,"names":["useState","useCallback","useRef","getHeight","useUpdateLayoutEffect","useMount","isEmpty","defer","useTableRows","props","prefix","wordWrap","data","expandedRowKeys","_useState","tableRowsMaxHeight","setTableRowsMaxHeight","tableRows","bindTableRowsRef","index","rowData","ref","current","calculateRowMaxHeight","nextTableRowsMaxHeight","curTableRows","Object","values","i","length","_curTableRows$i","row","cells","querySelectorAll","cellArray","Array","from","maxHeight","j","cell","h","Math","max","push"],"sources":["C:/Users/lenovo/OneDrive/Documents/local project/platfoorm45_technical_challenge/node_modules/rsuite-table/es/utils/useTableRows.js"],"sourcesContent":["'use client';\nimport { useState, useCallback, useRef } from 'react';\nimport getHeight from 'dom-lib/getHeight';\nimport useUpdateLayoutEffect from './useUpdateLayoutEffect';\nimport useMount from './useMount';\nimport isEmpty from 'lodash/isEmpty';\nimport defer from './defer';\n/**\n * The row information of the table, get the DOM of all rows, and summarize the row height.\n * @param props\n * @returns\n */\nvar useTableRows = function useTableRows(props) {\n  var prefix = props.prefix,\n    wordWrap = props.wordWrap,\n    data = props.data,\n    expandedRowKeys = props.expandedRowKeys;\n  var _useState = useState([]),\n    tableRowsMaxHeight = _useState[0],\n    setTableRowsMaxHeight = _useState[1];\n  var tableRows = useRef({});\n  var bindTableRowsRef = function bindTableRowsRef(index, rowData) {\n    return function (ref) {\n      if (ref) {\n        tableRows.current[index] = [ref, rowData];\n      }\n    };\n  };\n  var calculateRowMaxHeight = useCallback(function () {\n    if (wordWrap) {\n      var nextTableRowsMaxHeight = [];\n      var curTableRows = Object.values(tableRows.current);\n      for (var i = 0; i < curTableRows.length; i++) {\n        var _curTableRows$i = curTableRows[i],\n          row = _curTableRows$i[0];\n        if (row) {\n          var cells = row.querySelectorAll(\".\" + prefix('cell-wrap')) || [];\n          var cellArray = Array.from(cells);\n          var maxHeight = 0;\n          for (var j = 0; j < cellArray.length; j++) {\n            var cell = cellArray[j];\n            var h = getHeight(cell);\n            maxHeight = Math.max(maxHeight, h);\n          }\n          nextTableRowsMaxHeight.push(maxHeight);\n        }\n      }\n\n      // Can't perform a React state update on an unmounted component\n      if (!isEmpty(tableRows.current)) {\n        setTableRowsMaxHeight(nextTableRowsMaxHeight);\n      }\n    }\n  }, [prefix, wordWrap]);\n  useMount(function () {\n    defer(calculateRowMaxHeight);\n  });\n  useUpdateLayoutEffect(function () {\n    /**\n     * After the data is updated, the height of the cell DOM needs to be re-acquired,\n     * and what is often obtained is not the latest DOM that has been rendered.\n     * So use `defer` to delay obtaining the height of the cell DOM.\n     * TODO: To be improved\n     */\n    defer(calculateRowMaxHeight);\n  }, [data, expandedRowKeys]);\n  return {\n    bindTableRowsRef: bindTableRowsRef,\n    tableRowsMaxHeight: tableRowsMaxHeight,\n    tableRows: tableRows\n  };\n};\nexport default useTableRows;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}