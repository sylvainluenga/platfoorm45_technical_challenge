{"ast":null,"code":"'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _isUndefined from \"lodash/isUndefined\";\nimport _isNil from \"lodash/isNil\";\nimport { CHECK_STATE } from \"../internals/constants/index.js\";\nimport { attachParent } from \"../internals/utils/index.js\";\nimport { formatNodeRefKey } from \"../Tree/utils/index.js\";\n\n/**\n * Retrieves the children of a given parent node from a flattened node map.\n */\nfunction getChildrenByFlattenNodes(nodes, parent) {\n  if (!_isNil(parent.refKey) && _isNil(nodes[parent.refKey])) {\n    return [];\n  }\n  return Object.values(nodes).filter(function (item) {\n    var _item$parent;\n    return (item === null || item === void 0 ? void 0 : (_item$parent = item.parent) === null || _item$parent === void 0 ? void 0 : _item$parent.refKey) === parent.refKey && item.refKey && !nodes[item.refKey].uncheckable;\n  });\n}\n\n/**\n * Checks if every child of a given parent node is checked.\n */\nexport function isEveryChildChecked(parent, options) {\n  var nodes = options.nodes,\n    childrenKey = options.childrenKey;\n  if (_isNil(parent.refKey) || _isNil(nodes[parent.refKey])) {\n    return false;\n  }\n  var children = getChildrenByFlattenNodes(nodes, parent);\n  if (!children.length) {\n    var _nodes$parent$refKey$;\n    return (_nodes$parent$refKey$ = nodes[parent.refKey].check) !== null && _nodes$parent$refKey$ !== void 0 ? _nodes$parent$refKey$ : false;\n  }\n  return children.every(function (child) {\n    var _child$childrenKey;\n    if ((child === null || child === void 0 ? void 0 : (_child$childrenKey = child[childrenKey]) === null || _child$childrenKey === void 0 ? void 0 : _child$childrenKey.length) > 0) {\n      // fix: #3559\n      return isEveryChildChecked(child, {\n        nodes: nodes,\n        childrenKey: childrenKey\n      });\n    }\n    return !_isNil(child.refKey) && nodes[child.refKey].check;\n  });\n}\n\n/**\n * Checks if any child node is checked.\n */\nexport function isSomeChildChecked(nodes, parent, childrenKey) {\n  if (!_isNil(parent.refKey) && _isNil(nodes[parent.refKey])) {\n    return false;\n  }\n  var children = getChildrenByFlattenNodes(nodes, parent);\n  return children.some(function (child) {\n    var _child$childrenKey2;\n    if ((child === null || child === void 0 ? void 0 : (_child$childrenKey2 = child[childrenKey]) === null || _child$childrenKey2 === void 0 ? void 0 : _child$childrenKey2.length) > 0) {\n      return isSomeChildChecked(nodes, child, childrenKey);\n    }\n    return !_isNil(child.refKey) && nodes[child.refKey].check;\n  });\n}\n\n/**\n * Checks if any node in the data has a grandchild.\n */\nexport function hasGrandchild(data, childrenKey) {\n  return data.some(function (node) {\n    return Array.isArray(node[childrenKey]);\n  });\n}\n\n/**\n * Checks if all sibling nodes of a given node are uncheckable.\n */\nexport function isAllSiblingNodeUncheckable(node, nodes, uncheckableItemValues, valueKey) {\n  var list = [];\n  var parentNodeRefKey = node.parent ? node.parent.refKey : '';\n  Object.keys(nodes).forEach(function (refKey) {\n    var _curNode$parent;\n    var curNode = nodes[refKey];\n    if (_isNil(node.parent) && _isNil(curNode.parent)) {\n      list.push(curNode);\n    } else if (((_curNode$parent = curNode.parent) === null || _curNode$parent === void 0 ? void 0 : _curNode$parent.refKey) === parentNodeRefKey) {\n      list.push(curNode);\n    }\n  });\n  return list.every(function (node) {\n    return isNodeUncheckable(node, {\n      uncheckableItemValues: uncheckableItemValues,\n      valueKey: valueKey\n    });\n  });\n}\n\n/**\n * Checks if every first-level node is uncheckable based on the provided criteria.\n */\nexport function isEveryFirstLevelNodeUncheckable(nodes, uncheckableItemValues, valueKey) {\n  var list = [];\n  Object.keys(nodes).forEach(function (refKey) {\n    var curNode = nodes[refKey];\n    if (!curNode.parent) {\n      list.push(curNode);\n    }\n  });\n  return list.every(function (node) {\n    return isNodeUncheckable(node, {\n      uncheckableItemValues: uncheckableItemValues,\n      valueKey: valueKey\n    });\n  });\n}\n\n/**\n * Checks if a node is uncheckable.\n */\nexport function isNodeUncheckable(node, props) {\n  var _props$uncheckableIte = props.uncheckableItemValues,\n    uncheckableItemValues = _props$uncheckableIte === void 0 ? [] : _props$uncheckableIte,\n    valueKey = props.valueKey;\n  return uncheckableItemValues.some(function (value) {\n    return node[valueKey] === value;\n  });\n}\nexport function getFormattedTree(nodes, data, props) {\n  var childrenKey = props.childrenKey,\n    cascade = props.cascade;\n  return data.map(function (node) {\n    var formatted = _extends({}, node);\n    var curNode = nodes[node.refKey];\n    if (curNode) {\n      var _node$childrenKey;\n      var checkState = !_isUndefined(cascade) ? getNodeCheckState(curNode, {\n        cascade: cascade,\n        nodes: nodes,\n        childrenKey: childrenKey\n      }) : undefined;\n      formatted.check = curNode.check;\n      formatted.uncheckable = curNode.uncheckable;\n      attachParent(formatted, curNode.parent);\n      formatted.checkState = checkState;\n      if (((_node$childrenKey = node[childrenKey]) === null || _node$childrenKey === void 0 ? void 0 : _node$childrenKey.length) > 0) {\n        formatted[childrenKey] = getFormattedTree(nodes, formatted[childrenKey], props);\n      }\n    }\n    return formatted;\n  });\n}\n\n/**\n * Determines the disabled state of a tree node.\n */\nexport function getDisabledState(nodes, node, props) {\n  var _props$disabledItemVa = props.disabledItemValues,\n    disabledItemValues = _props$disabledItemVa === void 0 ? [] : _props$disabledItemVa,\n    valueKey = props.valueKey;\n  if (!_isNil(node.refKey) && _isNil(nodes[node.refKey])) {\n    return false;\n  }\n  return disabledItemValues.some(function (value) {\n    return node.refKey && nodes[node.refKey][valueKey] === value;\n  });\n}\n\n/**\n * Returns the default value for the check tree.\n */\nexport function getCheckTreeDefaultValue(value, uncheckableItemValues) {\n  if (Array.isArray(value) && Array.isArray(uncheckableItemValues)) {\n    return value.filter(function (v) {\n      return !uncheckableItemValues.includes(v);\n    });\n  }\n  return value;\n}\n\n/**\n * Retrieves the selected items from the given nodes.\n */\nexport function getSelectedItems(nodes, values) {\n  var checkedItems = [];\n  values.forEach(function (value) {\n    var refKey = formatNodeRefKey(value);\n    var node = nodes[refKey];\n    if (!_isNil(node)) {\n      checkedItems.push(node);\n    }\n  });\n  return checkedItems;\n}\n/**\n * Calculates the check state of a node in a check tree.\n */\nexport function getNodeCheckState(node, options) {\n  var nodes = options.nodes,\n    cascade = options.cascade,\n    childrenKey = options.childrenKey;\n  if (node.refKey === undefined) {\n    return CHECK_STATE.UNCHECK;\n  }\n  if (_isNil(nodes[node.refKey])) {\n    return CHECK_STATE.UNCHECK;\n  }\n  if (!node[childrenKey] || !node[childrenKey].length || !cascade) {\n    nodes[node.refKey].checkAll = false;\n    return node.check ? CHECK_STATE.CHECK : CHECK_STATE.UNCHECK;\n  }\n  if (isEveryChildChecked(node, {\n    nodes: nodes,\n    childrenKey: childrenKey\n  })) {\n    nodes[node.refKey].checkAll = true;\n    nodes[node.refKey].check = true;\n    return CHECK_STATE.CHECK;\n  }\n  if (isSomeChildChecked(nodes, node, childrenKey)) {\n    nodes[node.refKey].checkAll = false;\n    return CHECK_STATE.INDETERMINATE;\n  }\n  return CHECK_STATE.UNCHECK;\n}","map":{"version":3,"names":["_extends","_isUndefined","_isNil","CHECK_STATE","attachParent","formatNodeRefKey","getChildrenByFlattenNodes","nodes","parent","refKey","Object","values","filter","item","_item$parent","uncheckable","isEveryChildChecked","options","childrenKey","children","length","_nodes$parent$refKey$","check","every","child","_child$childrenKey","isSomeChildChecked","some","_child$childrenKey2","hasGrandchild","data","node","Array","isArray","isAllSiblingNodeUncheckable","uncheckableItemValues","valueKey","list","parentNodeRefKey","keys","forEach","_curNode$parent","curNode","push","isNodeUncheckable","isEveryFirstLevelNodeUncheckable","props","_props$uncheckableIte","value","getFormattedTree","cascade","map","formatted","_node$childrenKey","checkState","getNodeCheckState","undefined","getDisabledState","_props$disabledItemVa","disabledItemValues","getCheckTreeDefaultValue","v","includes","getSelectedItems","checkedItems","UNCHECK","checkAll","CHECK","INDETERMINATE"],"sources":["C:/Users/lenovo/OneDrive/Documents/local project/platfoorm45_technical_challenge/node_modules/rsuite/esm/CheckTree/utils.js"],"sourcesContent":["'use client';\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _isUndefined from \"lodash/isUndefined\";\nimport _isNil from \"lodash/isNil\";\nimport { CHECK_STATE } from \"../internals/constants/index.js\";\nimport { attachParent } from \"../internals/utils/index.js\";\nimport { formatNodeRefKey } from \"../Tree/utils/index.js\";\n\n/**\n * Retrieves the children of a given parent node from a flattened node map.\n */\nfunction getChildrenByFlattenNodes(nodes, parent) {\n  if (!_isNil(parent.refKey) && _isNil(nodes[parent.refKey])) {\n    return [];\n  }\n  return Object.values(nodes).filter(function (item) {\n    var _item$parent;\n    return (item === null || item === void 0 ? void 0 : (_item$parent = item.parent) === null || _item$parent === void 0 ? void 0 : _item$parent.refKey) === parent.refKey && item.refKey && !nodes[item.refKey].uncheckable;\n  });\n}\n\n/**\n * Checks if every child of a given parent node is checked.\n */\nexport function isEveryChildChecked(parent, options) {\n  var nodes = options.nodes,\n    childrenKey = options.childrenKey;\n  if (_isNil(parent.refKey) || _isNil(nodes[parent.refKey])) {\n    return false;\n  }\n  var children = getChildrenByFlattenNodes(nodes, parent);\n  if (!children.length) {\n    var _nodes$parent$refKey$;\n    return (_nodes$parent$refKey$ = nodes[parent.refKey].check) !== null && _nodes$parent$refKey$ !== void 0 ? _nodes$parent$refKey$ : false;\n  }\n  return children.every(function (child) {\n    var _child$childrenKey;\n    if ((child === null || child === void 0 ? void 0 : (_child$childrenKey = child[childrenKey]) === null || _child$childrenKey === void 0 ? void 0 : _child$childrenKey.length) > 0) {\n      // fix: #3559\n      return isEveryChildChecked(child, {\n        nodes: nodes,\n        childrenKey: childrenKey\n      });\n    }\n    return !_isNil(child.refKey) && nodes[child.refKey].check;\n  });\n}\n\n/**\n * Checks if any child node is checked.\n */\nexport function isSomeChildChecked(nodes, parent, childrenKey) {\n  if (!_isNil(parent.refKey) && _isNil(nodes[parent.refKey])) {\n    return false;\n  }\n  var children = getChildrenByFlattenNodes(nodes, parent);\n  return children.some(function (child) {\n    var _child$childrenKey2;\n    if ((child === null || child === void 0 ? void 0 : (_child$childrenKey2 = child[childrenKey]) === null || _child$childrenKey2 === void 0 ? void 0 : _child$childrenKey2.length) > 0) {\n      return isSomeChildChecked(nodes, child, childrenKey);\n    }\n    return !_isNil(child.refKey) && nodes[child.refKey].check;\n  });\n}\n\n/**\n * Checks if any node in the data has a grandchild.\n */\nexport function hasGrandchild(data, childrenKey) {\n  return data.some(function (node) {\n    return Array.isArray(node[childrenKey]);\n  });\n}\n\n/**\n * Checks if all sibling nodes of a given node are uncheckable.\n */\nexport function isAllSiblingNodeUncheckable(node, nodes, uncheckableItemValues, valueKey) {\n  var list = [];\n  var parentNodeRefKey = node.parent ? node.parent.refKey : '';\n  Object.keys(nodes).forEach(function (refKey) {\n    var _curNode$parent;\n    var curNode = nodes[refKey];\n    if (_isNil(node.parent) && _isNil(curNode.parent)) {\n      list.push(curNode);\n    } else if (((_curNode$parent = curNode.parent) === null || _curNode$parent === void 0 ? void 0 : _curNode$parent.refKey) === parentNodeRefKey) {\n      list.push(curNode);\n    }\n  });\n  return list.every(function (node) {\n    return isNodeUncheckable(node, {\n      uncheckableItemValues: uncheckableItemValues,\n      valueKey: valueKey\n    });\n  });\n}\n\n/**\n * Checks if every first-level node is uncheckable based on the provided criteria.\n */\nexport function isEveryFirstLevelNodeUncheckable(nodes, uncheckableItemValues, valueKey) {\n  var list = [];\n  Object.keys(nodes).forEach(function (refKey) {\n    var curNode = nodes[refKey];\n    if (!curNode.parent) {\n      list.push(curNode);\n    }\n  });\n  return list.every(function (node) {\n    return isNodeUncheckable(node, {\n      uncheckableItemValues: uncheckableItemValues,\n      valueKey: valueKey\n    });\n  });\n}\n\n/**\n * Checks if a node is uncheckable.\n */\nexport function isNodeUncheckable(node, props) {\n  var _props$uncheckableIte = props.uncheckableItemValues,\n    uncheckableItemValues = _props$uncheckableIte === void 0 ? [] : _props$uncheckableIte,\n    valueKey = props.valueKey;\n  return uncheckableItemValues.some(function (value) {\n    return node[valueKey] === value;\n  });\n}\nexport function getFormattedTree(nodes, data, props) {\n  var childrenKey = props.childrenKey,\n    cascade = props.cascade;\n  return data.map(function (node) {\n    var formatted = _extends({}, node);\n    var curNode = nodes[node.refKey];\n    if (curNode) {\n      var _node$childrenKey;\n      var checkState = !_isUndefined(cascade) ? getNodeCheckState(curNode, {\n        cascade: cascade,\n        nodes: nodes,\n        childrenKey: childrenKey\n      }) : undefined;\n      formatted.check = curNode.check;\n      formatted.uncheckable = curNode.uncheckable;\n      attachParent(formatted, curNode.parent);\n      formatted.checkState = checkState;\n      if (((_node$childrenKey = node[childrenKey]) === null || _node$childrenKey === void 0 ? void 0 : _node$childrenKey.length) > 0) {\n        formatted[childrenKey] = getFormattedTree(nodes, formatted[childrenKey], props);\n      }\n    }\n    return formatted;\n  });\n}\n\n/**\n * Determines the disabled state of a tree node.\n */\nexport function getDisabledState(nodes, node, props) {\n  var _props$disabledItemVa = props.disabledItemValues,\n    disabledItemValues = _props$disabledItemVa === void 0 ? [] : _props$disabledItemVa,\n    valueKey = props.valueKey;\n  if (!_isNil(node.refKey) && _isNil(nodes[node.refKey])) {\n    return false;\n  }\n  return disabledItemValues.some(function (value) {\n    return node.refKey && nodes[node.refKey][valueKey] === value;\n  });\n}\n\n/**\n * Returns the default value for the check tree.\n */\nexport function getCheckTreeDefaultValue(value, uncheckableItemValues) {\n  if (Array.isArray(value) && Array.isArray(uncheckableItemValues)) {\n    return value.filter(function (v) {\n      return !uncheckableItemValues.includes(v);\n    });\n  }\n  return value;\n}\n\n/**\n * Retrieves the selected items from the given nodes.\n */\nexport function getSelectedItems(nodes, values) {\n  var checkedItems = [];\n  values.forEach(function (value) {\n    var refKey = formatNodeRefKey(value);\n    var node = nodes[refKey];\n    if (!_isNil(node)) {\n      checkedItems.push(node);\n    }\n  });\n  return checkedItems;\n}\n/**\n * Calculates the check state of a node in a check tree.\n */\nexport function getNodeCheckState(node, options) {\n  var nodes = options.nodes,\n    cascade = options.cascade,\n    childrenKey = options.childrenKey;\n  if (node.refKey === undefined) {\n    return CHECK_STATE.UNCHECK;\n  }\n  if (_isNil(nodes[node.refKey])) {\n    return CHECK_STATE.UNCHECK;\n  }\n  if (!node[childrenKey] || !node[childrenKey].length || !cascade) {\n    nodes[node.refKey].checkAll = false;\n    return node.check ? CHECK_STATE.CHECK : CHECK_STATE.UNCHECK;\n  }\n  if (isEveryChildChecked(node, {\n    nodes: nodes,\n    childrenKey: childrenKey\n  })) {\n    nodes[node.refKey].checkAll = true;\n    nodes[node.refKey].check = true;\n    return CHECK_STATE.CHECK;\n  }\n  if (isSomeChildChecked(nodes, node, childrenKey)) {\n    nodes[node.refKey].checkAll = false;\n    return CHECK_STATE.INDETERMINATE;\n  }\n  return CHECK_STATE.UNCHECK;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}