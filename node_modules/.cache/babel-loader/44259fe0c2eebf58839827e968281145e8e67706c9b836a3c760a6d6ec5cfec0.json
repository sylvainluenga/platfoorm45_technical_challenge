{"ast":null,"code":"'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { getSelectIndexGap, isCursorAfterMonth, getDatePattern } from \"../DateInput/index.js\";\nexport var DateType = /*#__PURE__*/function (DateType) {\n  DateType[\"Start\"] = \"Start\";\n  DateType[\"End\"] = \"End\";\n  return DateType;\n}({});\nexport function getInputSelectedState(options) {\n  var input = options.input,\n    direction = options.direction,\n    formatStr = options.formatStr,\n    rangeFormatStr = options.rangeFormatStr,\n    localize = options.localize,\n    selectedMonth = options.selectedMonth,\n    _options$valueOffset = options.valueOffset,\n    valueOffset = _options$valueOffset === void 0 ? 0 : _options$valueOffset,\n    character = options.character,\n    dateType = options.dateType,\n    dateString = options.dateString;\n  var getPatternSelectedIndexes = function getPatternSelectedIndexes(pattern) {\n    var selectionStart = 0;\n    var selectionEnd = 0;\n    if (dateType === DateType.Start) {\n      selectionStart = rangeFormatStr.indexOf(pattern);\n      selectionEnd = rangeFormatStr.split(character)[0].lastIndexOf(pattern) + 1;\n    } else if (dateType === DateType.End) {\n      var position = rangeFormatStr.indexOf(character) + character.length;\n      selectionStart = rangeFormatStr.indexOf(pattern, position);\n      selectionEnd = rangeFormatStr.lastIndexOf(pattern) + 1;\n    }\n    var endDateGap = dateString.indexOf(character) - rangeFormatStr.indexOf(character);\n\n    // If the date type is end, and the end date is not selected, the selection range needs to be adjusted.\n    if (dateType === DateType.End && endDateGap > 0) {\n      selectionStart += endDateGap;\n      selectionEnd += endDateGap;\n    }\n    var gap = getSelectIndexGap({\n      pattern: pattern,\n      formatStr: formatStr,\n      valueOffset: valueOffset,\n      selectedMonth: selectedMonth,\n      localize: localize\n    });\n    var isSelectedMonth = pattern === 'M';\n    var isNullMonth = selectedMonth === null && !(isSelectedMonth && valueOffset !== 0);\n\n    // If the month is null and the valueOffset is 0, the month will not be updated, and the gap is 0 at this time.\n    if (isNullMonth) {\n      return {\n        selectionStart: selectionStart,\n        selectionEnd: selectionEnd\n      };\n    }\n    if (isSelectedMonth) {\n      return {\n        selectionStart: selectionStart,\n        selectionEnd: selectionEnd + gap\n      };\n    }\n    if (isCursorAfterMonth(selectionStart, formatStr)) {\n      return {\n        selectionStart: selectionStart + gap,\n        selectionEnd: selectionEnd + gap\n      };\n    }\n    return {\n      selectionStart: selectionStart,\n      selectionEnd: selectionEnd\n    };\n  };\n  if (typeof input.selectionEnd === 'number' && typeof input.selectionStart === 'number') {\n    var index = input.selectionStart;\n    var positionOffset = -1;\n    if (direction === 'left') {\n      index = input.selectionStart - 1;\n    } else if (direction === 'right') {\n      index = input.selectionEnd + 1;\n      positionOffset = 1;\n    }\n\n    // The start position of the index of the end date\n    var endDateIndex = dateString.indexOf(character) + character.length;\n    var datePattern = getDatePattern({\n      selectionIndex: dateType === DateType.End ? index - endDateIndex : index,\n      positionOffset: positionOffset,\n      formatStr: formatStr,\n      dateString: dateString,\n      valueOffset: valueOffset,\n      selectedMonth: selectedMonth,\n      localize: localize\n    });\n    var indexes = getPatternSelectedIndexes(datePattern);\n    return _extends({\n      selectedPattern: datePattern\n    }, indexes);\n  }\n  return {\n    selectedPattern: 'y',\n    selectionStart: 0,\n    selectionEnd: 0\n  };\n}\nexport function getDateType(dateString, character, cursorIndex) {\n  var splitIndex = dateString.indexOf(character);\n  if (cursorIndex > splitIndex) {\n    return DateType.End;\n  }\n  return DateType.Start;\n}\nexport function isSwitchDateType(dateString, character, cursorIndex, direction) {\n  var characterIndex = dateString.indexOf(character);\n  var startIndex = cursorIndex;\n  var endIndex = startIndex + character.length;\n  if (direction === 'left') {\n    endIndex = cursorIndex;\n    startIndex = endIndex - character.length;\n  }\n\n  // Check whether the cursor is a separator before and after\n  if (dateString.substring(startIndex, endIndex) === character) {\n    return true;\n  }\n\n  // Check whether the cursor is a number or letter before and after. If not, switch the date type.\n  // eg: `2020年12月01日`, the cursor is behind 01, press the right key, and switch to the end date.\n  if (direction === 'right') {\n    if (!dateString.substring(cursorIndex, characterIndex).match(/[0-9a-zA-Z]/)) {\n      return true;\n    }\n  }\n  if (!dateString.substring(characterIndex, cursorIndex).match(/[0-9a-zA-Z]/)) {\n    return true;\n  }\n  return false;\n}","map":{"version":3,"names":["_extends","getSelectIndexGap","isCursorAfterMonth","getDatePattern","DateType","getInputSelectedState","options","input","direction","formatStr","rangeFormatStr","localize","selectedMonth","_options$valueOffset","valueOffset","character","dateType","dateString","getPatternSelectedIndexes","pattern","selectionStart","selectionEnd","Start","indexOf","split","lastIndexOf","End","position","length","endDateGap","gap","isSelectedMonth","isNullMonth","index","positionOffset","endDateIndex","datePattern","selectionIndex","indexes","selectedPattern","getDateType","cursorIndex","splitIndex","isSwitchDateType","characterIndex","startIndex","endIndex","substring","match"],"sources":["C:/Users/lenovo/OneDrive/Documents/local project/platfoorm45_technical_challenge/node_modules/rsuite/esm/DateRangeInput/utils.js"],"sourcesContent":["'use client';\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { getSelectIndexGap, isCursorAfterMonth, getDatePattern } from \"../DateInput/index.js\";\nexport var DateType = /*#__PURE__*/function (DateType) {\n  DateType[\"Start\"] = \"Start\";\n  DateType[\"End\"] = \"End\";\n  return DateType;\n}({});\nexport function getInputSelectedState(options) {\n  var input = options.input,\n    direction = options.direction,\n    formatStr = options.formatStr,\n    rangeFormatStr = options.rangeFormatStr,\n    localize = options.localize,\n    selectedMonth = options.selectedMonth,\n    _options$valueOffset = options.valueOffset,\n    valueOffset = _options$valueOffset === void 0 ? 0 : _options$valueOffset,\n    character = options.character,\n    dateType = options.dateType,\n    dateString = options.dateString;\n  var getPatternSelectedIndexes = function getPatternSelectedIndexes(pattern) {\n    var selectionStart = 0;\n    var selectionEnd = 0;\n    if (dateType === DateType.Start) {\n      selectionStart = rangeFormatStr.indexOf(pattern);\n      selectionEnd = rangeFormatStr.split(character)[0].lastIndexOf(pattern) + 1;\n    } else if (dateType === DateType.End) {\n      var position = rangeFormatStr.indexOf(character) + character.length;\n      selectionStart = rangeFormatStr.indexOf(pattern, position);\n      selectionEnd = rangeFormatStr.lastIndexOf(pattern) + 1;\n    }\n    var endDateGap = dateString.indexOf(character) - rangeFormatStr.indexOf(character);\n\n    // If the date type is end, and the end date is not selected, the selection range needs to be adjusted.\n    if (dateType === DateType.End && endDateGap > 0) {\n      selectionStart += endDateGap;\n      selectionEnd += endDateGap;\n    }\n    var gap = getSelectIndexGap({\n      pattern: pattern,\n      formatStr: formatStr,\n      valueOffset: valueOffset,\n      selectedMonth: selectedMonth,\n      localize: localize\n    });\n    var isSelectedMonth = pattern === 'M';\n    var isNullMonth = selectedMonth === null && !(isSelectedMonth && valueOffset !== 0);\n\n    // If the month is null and the valueOffset is 0, the month will not be updated, and the gap is 0 at this time.\n    if (isNullMonth) {\n      return {\n        selectionStart: selectionStart,\n        selectionEnd: selectionEnd\n      };\n    }\n    if (isSelectedMonth) {\n      return {\n        selectionStart: selectionStart,\n        selectionEnd: selectionEnd + gap\n      };\n    }\n    if (isCursorAfterMonth(selectionStart, formatStr)) {\n      return {\n        selectionStart: selectionStart + gap,\n        selectionEnd: selectionEnd + gap\n      };\n    }\n    return {\n      selectionStart: selectionStart,\n      selectionEnd: selectionEnd\n    };\n  };\n  if (typeof input.selectionEnd === 'number' && typeof input.selectionStart === 'number') {\n    var index = input.selectionStart;\n    var positionOffset = -1;\n    if (direction === 'left') {\n      index = input.selectionStart - 1;\n    } else if (direction === 'right') {\n      index = input.selectionEnd + 1;\n      positionOffset = 1;\n    }\n\n    // The start position of the index of the end date\n    var endDateIndex = dateString.indexOf(character) + character.length;\n    var datePattern = getDatePattern({\n      selectionIndex: dateType === DateType.End ? index - endDateIndex : index,\n      positionOffset: positionOffset,\n      formatStr: formatStr,\n      dateString: dateString,\n      valueOffset: valueOffset,\n      selectedMonth: selectedMonth,\n      localize: localize\n    });\n    var indexes = getPatternSelectedIndexes(datePattern);\n    return _extends({\n      selectedPattern: datePattern\n    }, indexes);\n  }\n  return {\n    selectedPattern: 'y',\n    selectionStart: 0,\n    selectionEnd: 0\n  };\n}\nexport function getDateType(dateString, character, cursorIndex) {\n  var splitIndex = dateString.indexOf(character);\n  if (cursorIndex > splitIndex) {\n    return DateType.End;\n  }\n  return DateType.Start;\n}\nexport function isSwitchDateType(dateString, character, cursorIndex, direction) {\n  var characterIndex = dateString.indexOf(character);\n  var startIndex = cursorIndex;\n  var endIndex = startIndex + character.length;\n  if (direction === 'left') {\n    endIndex = cursorIndex;\n    startIndex = endIndex - character.length;\n  }\n\n  // Check whether the cursor is a separator before and after\n  if (dateString.substring(startIndex, endIndex) === character) {\n    return true;\n  }\n\n  // Check whether the cursor is a number or letter before and after. If not, switch the date type.\n  // eg: `2020年12月01日`, the cursor is behind 01, press the right key, and switch to the end date.\n  if (direction === 'right') {\n    if (!dateString.substring(cursorIndex, characterIndex).match(/[0-9a-zA-Z]/)) {\n      return true;\n    }\n  }\n  if (!dateString.substring(characterIndex, cursorIndex).match(/[0-9a-zA-Z]/)) {\n    return true;\n  }\n  return false;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}