{"ast":null,"code":"'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport isString from 'lodash/isString';\nimport isNumber from 'lodash/isNumber';\nimport adjustCaretPosition from \"./adjustCaretPosition.js\";\nimport conformToMask from \"./conformToMask.js\";\nimport { convertMaskToPlaceholder, processCaretTraps, defaultPlaceholderChar } from \"./utilities.js\";\nimport { safeSetSelection } from \"../internals/utils/index.js\";\nvar emptyString = '';\nvar strObject = 'object';\nexport default function createTextMaskInputElement(config) {\n  // Anything that we will need to keep between `update` calls, we will store in this `state` object.\n  var state = {\n    previousConformedValue: undefined,\n    previousPlaceholder: undefined\n  };\n  return {\n    state: state,\n    // `update` is called by framework components whenever they want to update the `value` of the input element.\n    // The caller can send a `rawValue` to be conformed and set on the input element. However, the default use-case\n    // is for this to be read from the `inputElement` directly.\n    update: function update(rawValue, _temp) {\n      var _pipeResults, _pipeResults2;\n      var _ref = _temp === void 0 ? config : _temp,\n        inputElement = _ref.inputElement,\n        providedMask = _ref.mask,\n        guide = _ref.guide,\n        pipe = _ref.pipe,\n        _ref$placeholderChar = _ref.placeholderChar,\n        placeholderChar = _ref$placeholderChar === void 0 ? defaultPlaceholderChar : _ref$placeholderChar,\n        _ref$keepCharPosition = _ref.keepCharPositions,\n        keepCharPositions = _ref$keepCharPosition === void 0 ? false : _ref$keepCharPosition,\n        _ref$showMask = _ref.showMask,\n        showMask = _ref$showMask === void 0 ? false : _ref$showMask;\n      // if `rawValue` is `undefined`, read from the `inputElement`\n      if (typeof rawValue === 'undefined') {\n        rawValue = inputElement.value;\n      }\n\n      // If `rawValue` equals `state.previousConformedValue`, we don't need to change anything. So, we return.\n      // This check is here to handle controlled framework components that repeat the `update` call on every render.\n      if (rawValue === state.previousConformedValue) {\n        return;\n      }\n\n      // Text Mask accepts masks that are a combination of a `mask` and a `pipe` that work together. If such a `mask` is\n      // passed, we destructure it below, so the rest of the code can work normally as if a separate `mask` and a `pipe`\n      // were passed.\n      if (typeof providedMask === strObject && providedMask.pipe !== undefined && providedMask.mask !== undefined) {\n        pipe = providedMask.pipe;\n        providedMask = providedMask.mask;\n      }\n\n      // The `placeholder` is an essential piece of how Text Mask works. For a mask like `(111)`, the placeholder would\n      // be `(___)` if the `placeholderChar` is set to `_`.\n      var placeholder;\n\n      // We don't know what the mask would be yet. If it is an array, we take it as is, but if it's a function, we will\n      // have to call that function to get the mask array.\n      var mask;\n\n      // If the provided mask is an array, we can call `convertMaskToPlaceholder` here once and we'll always have the\n      // correct `placeholder`.\n      if (providedMask instanceof Array) {\n        placeholder = convertMaskToPlaceholder(providedMask, placeholderChar);\n      }\n\n      // In framework components that support reactivity, it's possible to turn off masking by passing\n      // `false` for `mask` after initialization. See https://github.com/text-mask/text-mask/pull/359\n      if (providedMask === false) {\n        return;\n      }\n\n      // We check the provided `rawValue` before moving further.\n      // If it's something we can't work with `getSafeRawValue` will throw.\n      var safeRawValue = getSafeRawValue(rawValue);\n\n      // `selectionEnd` indicates to us where the caret position is after the user has typed into the input\n      var currentCaretPosition = inputElement.selectionEnd;\n\n      // We need to know what the `previousConformedValue` and `previousPlaceholder` is from the previous `update` call\n      var previousConformedValue = state.previousConformedValue,\n        previousPlaceholder = state.previousPlaceholder;\n      var caretTrapIndexes;\n\n      // If the `providedMask` is a function. We need to call it at every `update` to get the `mask` array.\n      // Then we also need to get the `placeholder`\n      if (typeof providedMask === 'function') {\n        mask = providedMask(safeRawValue, {\n          currentCaretPosition: currentCaretPosition,\n          previousConformedValue: previousConformedValue,\n          placeholderChar: placeholderChar\n        });\n\n        // disable masking if `mask` is `false`\n        if (mask === false) {\n          return;\n        }\n\n        // mask functions can setup caret traps to have some control over how the caret moves. We need to process\n        // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask and return\n        // the indexes of the caret traps.\n        var _processCaretTraps = processCaretTraps(mask),\n          maskWithoutCaretTraps = _processCaretTraps.maskWithoutCaretTraps,\n          indexes = _processCaretTraps.indexes;\n        mask = maskWithoutCaretTraps; // The processed mask is what we're interested in\n        caretTrapIndexes = indexes; // And we need to store these indexes because they're needed by `adjustCaretPosition`\n\n        placeholder = convertMaskToPlaceholder(mask, placeholderChar);\n\n        // If the `providedMask` is not a function, we just use it as-is.\n      } else {\n        mask = providedMask;\n      }\n\n      // The following object will be passed to `conformToMask` to determine how the `rawValue` will be conformed\n      var conformToMaskConfig = {\n        previousConformedValue: previousConformedValue,\n        guide: guide,\n        placeholderChar: placeholderChar,\n        pipe: pipe,\n        placeholder: placeholder,\n        currentCaretPosition: currentCaretPosition,\n        keepCharPositions: keepCharPositions\n      };\n\n      // `conformToMask` returns `conformedValue` as part of an object for future API flexibility\n      var _conformToMask = conformToMask(safeRawValue, mask, conformToMaskConfig),\n        conformedValue = _conformToMask.conformedValue;\n\n      // The following few lines are to support the `pipe` feature.\n      var piped = typeof pipe === 'function';\n      var pipeResults = {};\n\n      // If `pipe` is a function, we call it.\n      if (piped) {\n        // `pipe` receives the `conformedValue` and the configurations with which `conformToMask` was called.\n        pipeResults = pipe(conformedValue, _extends({\n          rawValue: safeRawValue\n        }, conformToMaskConfig));\n\n        // `pipeResults` should be an object. But as a convenience, we allow the pipe author to just return `false` to\n        // indicate rejection. Or return just a string when there are no piped characters.\n        // If the `pipe` returns `false` or a string, the block below turns it into an object that the rest\n        // of the code can work with.\n        if (typeof pipeResults === 'boolean' && pipeResults === false) {\n          // If the `pipe` rejects `conformedValue`, we use the `previousConformedValue`, and set `rejected` to `true`.\n          pipeResults = {\n            value: previousConformedValue,\n            rejected: true\n          };\n        } else if (isString(pipeResults)) {\n          pipeResults = {\n            value: pipeResults\n          };\n        }\n      }\n\n      // Before we proceed, we need to know which conformed value to use, the one returned by the pipe or the one\n      // returned by `conformToMask`.\n      var finalConformedValue = piped ? (_pipeResults = pipeResults) === null || _pipeResults === void 0 ? void 0 : _pipeResults.value : conformedValue;\n\n      // After determining the conformed value, we will need to know where to set\n      // the caret position. `adjustCaretPosition` will tell us.\n      var adjustedCaretPosition = adjustCaretPosition({\n        previousConformedValue: previousConformedValue,\n        previousPlaceholder: previousPlaceholder,\n        conformedValue: finalConformedValue,\n        placeholder: placeholder,\n        rawValue: safeRawValue,\n        currentCaretPosition: currentCaretPosition,\n        placeholderChar: placeholderChar,\n        indexesOfPipedChars: (_pipeResults2 = pipeResults) === null || _pipeResults2 === void 0 ? void 0 : _pipeResults2.indexesOfPipedChars,\n        caretTrapIndexes: caretTrapIndexes\n      });\n\n      // Text Mask sets the input value to an empty string when the condition below is set. It provides a better UX.\n      var inputValueShouldBeEmpty = finalConformedValue === placeholder && adjustedCaretPosition === 0;\n      var emptyValue = showMask ? placeholder : emptyString;\n      var inputElementValue = inputValueShouldBeEmpty ? emptyValue : finalConformedValue;\n      state.previousConformedValue = inputElementValue; // store value for access for next time\n      state.previousPlaceholder = placeholder;\n\n      // In some cases, this `update` method will be repeatedly called with a raw value that has already been conformed\n      // and set to `inputElement.value`. The below check guards against needlessly readjusting the input state.\n      // See https://github.com/text-mask/text-mask/issues/231\n      if (inputElement.value === inputElementValue) {\n        return;\n      }\n      inputElement.value = inputElementValue; // set the input value\n\n      if (typeof adjustedCaretPosition === 'number') {\n        safeSetSelection(inputElement, adjustedCaretPosition, adjustedCaretPosition); // adjust caret position\n      }\n    }\n  };\n}\nfunction getSafeRawValue(inputValue) {\n  if (isString(inputValue)) {\n    return inputValue;\n  } else if (isNumber(inputValue)) {\n    return String(inputValue);\n  } else if (inputValue === undefined || inputValue === null) {\n    return emptyString;\n  } else {\n    throw new Error(\"The 'value' provided to Text Mask needs to be a string or a number. The value received was:\\n\\n \" + JSON.stringify(inputValue));\n  }\n}","map":{"version":3,"names":["_extends","isString","isNumber","adjustCaretPosition","conformToMask","convertMaskToPlaceholder","processCaretTraps","defaultPlaceholderChar","safeSetSelection","emptyString","strObject","createTextMaskInputElement","config","state","previousConformedValue","undefined","previousPlaceholder","update","rawValue","_temp","_pipeResults","_pipeResults2","_ref","inputElement","providedMask","mask","guide","pipe","_ref$placeholderChar","placeholderChar","_ref$keepCharPosition","keepCharPositions","_ref$showMask","showMask","value","placeholder","Array","safeRawValue","getSafeRawValue","currentCaretPosition","selectionEnd","caretTrapIndexes","_processCaretTraps","maskWithoutCaretTraps","indexes","conformToMaskConfig","_conformToMask","conformedValue","piped","pipeResults","rejected","finalConformedValue","adjustedCaretPosition","indexesOfPipedChars","inputValueShouldBeEmpty","emptyValue","inputElementValue","inputValue","String","Error","JSON","stringify"],"sources":["C:/Users/lenovo/OneDrive/Documents/local project/platfoorm45_technical_challenge/node_modules/rsuite/esm/MaskedInput/createTextMaskInputElement.js"],"sourcesContent":["'use client';\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport isString from 'lodash/isString';\nimport isNumber from 'lodash/isNumber';\nimport adjustCaretPosition from \"./adjustCaretPosition.js\";\nimport conformToMask from \"./conformToMask.js\";\nimport { convertMaskToPlaceholder, processCaretTraps, defaultPlaceholderChar } from \"./utilities.js\";\nimport { safeSetSelection } from \"../internals/utils/index.js\";\nvar emptyString = '';\nvar strObject = 'object';\nexport default function createTextMaskInputElement(config) {\n  // Anything that we will need to keep between `update` calls, we will store in this `state` object.\n  var state = {\n    previousConformedValue: undefined,\n    previousPlaceholder: undefined\n  };\n  return {\n    state: state,\n    // `update` is called by framework components whenever they want to update the `value` of the input element.\n    // The caller can send a `rawValue` to be conformed and set on the input element. However, the default use-case\n    // is for this to be read from the `inputElement` directly.\n    update: function update(rawValue, _temp) {\n      var _pipeResults, _pipeResults2;\n      var _ref = _temp === void 0 ? config : _temp,\n        inputElement = _ref.inputElement,\n        providedMask = _ref.mask,\n        guide = _ref.guide,\n        pipe = _ref.pipe,\n        _ref$placeholderChar = _ref.placeholderChar,\n        placeholderChar = _ref$placeholderChar === void 0 ? defaultPlaceholderChar : _ref$placeholderChar,\n        _ref$keepCharPosition = _ref.keepCharPositions,\n        keepCharPositions = _ref$keepCharPosition === void 0 ? false : _ref$keepCharPosition,\n        _ref$showMask = _ref.showMask,\n        showMask = _ref$showMask === void 0 ? false : _ref$showMask;\n      // if `rawValue` is `undefined`, read from the `inputElement`\n      if (typeof rawValue === 'undefined') {\n        rawValue = inputElement.value;\n      }\n\n      // If `rawValue` equals `state.previousConformedValue`, we don't need to change anything. So, we return.\n      // This check is here to handle controlled framework components that repeat the `update` call on every render.\n      if (rawValue === state.previousConformedValue) {\n        return;\n      }\n\n      // Text Mask accepts masks that are a combination of a `mask` and a `pipe` that work together. If such a `mask` is\n      // passed, we destructure it below, so the rest of the code can work normally as if a separate `mask` and a `pipe`\n      // were passed.\n      if (typeof providedMask === strObject && providedMask.pipe !== undefined && providedMask.mask !== undefined) {\n        pipe = providedMask.pipe;\n        providedMask = providedMask.mask;\n      }\n\n      // The `placeholder` is an essential piece of how Text Mask works. For a mask like `(111)`, the placeholder would\n      // be `(___)` if the `placeholderChar` is set to `_`.\n      var placeholder;\n\n      // We don't know what the mask would be yet. If it is an array, we take it as is, but if it's a function, we will\n      // have to call that function to get the mask array.\n      var mask;\n\n      // If the provided mask is an array, we can call `convertMaskToPlaceholder` here once and we'll always have the\n      // correct `placeholder`.\n      if (providedMask instanceof Array) {\n        placeholder = convertMaskToPlaceholder(providedMask, placeholderChar);\n      }\n\n      // In framework components that support reactivity, it's possible to turn off masking by passing\n      // `false` for `mask` after initialization. See https://github.com/text-mask/text-mask/pull/359\n      if (providedMask === false) {\n        return;\n      }\n\n      // We check the provided `rawValue` before moving further.\n      // If it's something we can't work with `getSafeRawValue` will throw.\n      var safeRawValue = getSafeRawValue(rawValue);\n\n      // `selectionEnd` indicates to us where the caret position is after the user has typed into the input\n      var currentCaretPosition = inputElement.selectionEnd;\n\n      // We need to know what the `previousConformedValue` and `previousPlaceholder` is from the previous `update` call\n      var previousConformedValue = state.previousConformedValue,\n        previousPlaceholder = state.previousPlaceholder;\n      var caretTrapIndexes;\n\n      // If the `providedMask` is a function. We need to call it at every `update` to get the `mask` array.\n      // Then we also need to get the `placeholder`\n      if (typeof providedMask === 'function') {\n        mask = providedMask(safeRawValue, {\n          currentCaretPosition: currentCaretPosition,\n          previousConformedValue: previousConformedValue,\n          placeholderChar: placeholderChar\n        });\n\n        // disable masking if `mask` is `false`\n        if (mask === false) {\n          return;\n        }\n\n        // mask functions can setup caret traps to have some control over how the caret moves. We need to process\n        // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask and return\n        // the indexes of the caret traps.\n        var _processCaretTraps = processCaretTraps(mask),\n          maskWithoutCaretTraps = _processCaretTraps.maskWithoutCaretTraps,\n          indexes = _processCaretTraps.indexes;\n        mask = maskWithoutCaretTraps; // The processed mask is what we're interested in\n        caretTrapIndexes = indexes; // And we need to store these indexes because they're needed by `adjustCaretPosition`\n\n        placeholder = convertMaskToPlaceholder(mask, placeholderChar);\n\n        // If the `providedMask` is not a function, we just use it as-is.\n      } else {\n        mask = providedMask;\n      }\n\n      // The following object will be passed to `conformToMask` to determine how the `rawValue` will be conformed\n      var conformToMaskConfig = {\n        previousConformedValue: previousConformedValue,\n        guide: guide,\n        placeholderChar: placeholderChar,\n        pipe: pipe,\n        placeholder: placeholder,\n        currentCaretPosition: currentCaretPosition,\n        keepCharPositions: keepCharPositions\n      };\n\n      // `conformToMask` returns `conformedValue` as part of an object for future API flexibility\n      var _conformToMask = conformToMask(safeRawValue, mask, conformToMaskConfig),\n        conformedValue = _conformToMask.conformedValue;\n\n      // The following few lines are to support the `pipe` feature.\n      var piped = typeof pipe === 'function';\n      var pipeResults = {};\n\n      // If `pipe` is a function, we call it.\n      if (piped) {\n        // `pipe` receives the `conformedValue` and the configurations with which `conformToMask` was called.\n        pipeResults = pipe(conformedValue, _extends({\n          rawValue: safeRawValue\n        }, conformToMaskConfig));\n\n        // `pipeResults` should be an object. But as a convenience, we allow the pipe author to just return `false` to\n        // indicate rejection. Or return just a string when there are no piped characters.\n        // If the `pipe` returns `false` or a string, the block below turns it into an object that the rest\n        // of the code can work with.\n        if (typeof pipeResults === 'boolean' && pipeResults === false) {\n          // If the `pipe` rejects `conformedValue`, we use the `previousConformedValue`, and set `rejected` to `true`.\n          pipeResults = {\n            value: previousConformedValue,\n            rejected: true\n          };\n        } else if (isString(pipeResults)) {\n          pipeResults = {\n            value: pipeResults\n          };\n        }\n      }\n\n      // Before we proceed, we need to know which conformed value to use, the one returned by the pipe or the one\n      // returned by `conformToMask`.\n      var finalConformedValue = piped ? (_pipeResults = pipeResults) === null || _pipeResults === void 0 ? void 0 : _pipeResults.value : conformedValue;\n\n      // After determining the conformed value, we will need to know where to set\n      // the caret position. `adjustCaretPosition` will tell us.\n      var adjustedCaretPosition = adjustCaretPosition({\n        previousConformedValue: previousConformedValue,\n        previousPlaceholder: previousPlaceholder,\n        conformedValue: finalConformedValue,\n        placeholder: placeholder,\n        rawValue: safeRawValue,\n        currentCaretPosition: currentCaretPosition,\n        placeholderChar: placeholderChar,\n        indexesOfPipedChars: (_pipeResults2 = pipeResults) === null || _pipeResults2 === void 0 ? void 0 : _pipeResults2.indexesOfPipedChars,\n        caretTrapIndexes: caretTrapIndexes\n      });\n\n      // Text Mask sets the input value to an empty string when the condition below is set. It provides a better UX.\n      var inputValueShouldBeEmpty = finalConformedValue === placeholder && adjustedCaretPosition === 0;\n      var emptyValue = showMask ? placeholder : emptyString;\n      var inputElementValue = inputValueShouldBeEmpty ? emptyValue : finalConformedValue;\n      state.previousConformedValue = inputElementValue; // store value for access for next time\n      state.previousPlaceholder = placeholder;\n\n      // In some cases, this `update` method will be repeatedly called with a raw value that has already been conformed\n      // and set to `inputElement.value`. The below check guards against needlessly readjusting the input state.\n      // See https://github.com/text-mask/text-mask/issues/231\n      if (inputElement.value === inputElementValue) {\n        return;\n      }\n      inputElement.value = inputElementValue; // set the input value\n\n      if (typeof adjustedCaretPosition === 'number') {\n        safeSetSelection(inputElement, adjustedCaretPosition, adjustedCaretPosition); // adjust caret position\n      }\n    }\n  };\n}\nfunction getSafeRawValue(inputValue) {\n  if (isString(inputValue)) {\n    return inputValue;\n  } else if (isNumber(inputValue)) {\n    return String(inputValue);\n  } else if (inputValue === undefined || inputValue === null) {\n    return emptyString;\n  } else {\n    throw new Error(\"The 'value' provided to Text Mask needs to be a string or a number. The value received was:\\n\\n \" + JSON.stringify(inputValue));\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}