{"ast":null,"code":"/*!\n * set-value <https://github.com/jonschlinkert/set-value>\n *\n * Copyright (c) Jon Schlinkert (https://github.com/jonschlinkert).\n * Released under the MIT License.\n */\n\n'use strict';\n\nconst {\n  deleteProperty\n} = Reflect;\nconst isPrimitive = require('is-primitive');\nconst isPlainObject = require('is-plain-object');\nconst isObject = value => {\n  return typeof value === 'object' && value !== null || typeof value === 'function';\n};\nconst isUnsafeKey = key => {\n  return key === '__proto__' || key === 'constructor' || key === 'prototype';\n};\nconst validateKey = key => {\n  if (!isPrimitive(key)) {\n    throw new TypeError('Object keys must be strings or symbols');\n  }\n  if (isUnsafeKey(key)) {\n    throw new Error(`Cannot set unsafe key: \"${key}\"`);\n  }\n};\nconst toStringKey = input => {\n  return Array.isArray(input) ? input.flat().map(String).join(',') : input;\n};\nconst createMemoKey = (input, options) => {\n  if (typeof input !== 'string' || !options) return input;\n  let key = input + ';';\n  if (options.arrays !== undefined) key += `arrays=${options.arrays};`;\n  if (options.separator !== undefined) key += `separator=${options.separator};`;\n  if (options.split !== undefined) key += `split=${options.split};`;\n  if (options.merge !== undefined) key += `merge=${options.merge};`;\n  if (options.preservePaths !== undefined) key += `preservePaths=${options.preservePaths};`;\n  return key;\n};\nconst memoize = (input, options, fn) => {\n  const key = toStringKey(options ? createMemoKey(input, options) : input);\n  validateKey(key);\n  const value = setValue.cache.get(key) || fn();\n  setValue.cache.set(key, value);\n  return value;\n};\nconst splitString = (input, options = {}) => {\n  const sep = options.separator || '.';\n  const preserve = sep === '/' ? false : options.preservePaths;\n  if (typeof input === 'string' && preserve !== false && /\\//.test(input)) {\n    return [input];\n  }\n  const parts = [];\n  let part = '';\n  const push = part => {\n    let number;\n    if (part.trim() !== '' && Number.isInteger(number = Number(part))) {\n      parts.push(number);\n    } else {\n      parts.push(part);\n    }\n  };\n  for (let i = 0; i < input.length; i++) {\n    const value = input[i];\n    if (value === '\\\\') {\n      part += input[++i];\n      continue;\n    }\n    if (value === sep) {\n      push(part);\n      part = '';\n      continue;\n    }\n    part += value;\n  }\n  if (part) {\n    push(part);\n  }\n  return parts;\n};\nconst split = (input, options) => {\n  if (options && typeof options.split === 'function') return options.split(input);\n  if (typeof input === 'symbol') return [input];\n  if (Array.isArray(input)) return input;\n  return memoize(input, options, () => splitString(input, options));\n};\nconst assignProp = (obj, prop, value, options) => {\n  validateKey(prop);\n\n  // Delete property when \"value\" is undefined\n  if (value === undefined) {\n    deleteProperty(obj, prop);\n  } else if (options && options.merge) {\n    const merge = options.merge === 'function' ? options.merge : Object.assign;\n\n    // Only merge plain objects\n    if (merge && isPlainObject(obj[prop]) && isPlainObject(value)) {\n      obj[prop] = merge(obj[prop], value);\n    } else {\n      obj[prop] = value;\n    }\n  } else {\n    obj[prop] = value;\n  }\n  return obj;\n};\nconst setValue = (target, path, value, options) => {\n  if (!path || !isObject(target)) return target;\n  const keys = split(path, options);\n  let obj = target;\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const next = keys[i + 1];\n    validateKey(key);\n    if (next === undefined) {\n      assignProp(obj, key, value, options);\n      break;\n    }\n    if (typeof next === 'number' && !Array.isArray(obj[key])) {\n      obj = obj[key] = [];\n      continue;\n    }\n    if (!isObject(obj[key])) {\n      obj[key] = {};\n    }\n    obj = obj[key];\n  }\n  return target;\n};\nsetValue.split = split;\nsetValue.cache = new Map();\nsetValue.clear = () => {\n  setValue.cache = new Map();\n};\nmodule.exports = setValue;","map":{"version":3,"names":["deleteProperty","Reflect","isPrimitive","require","isPlainObject","isObject","value","isUnsafeKey","key","validateKey","TypeError","Error","toStringKey","input","Array","isArray","flat","map","String","join","createMemoKey","options","arrays","undefined","separator","split","merge","preservePaths","memoize","fn","setValue","cache","get","set","splitString","sep","preserve","test","parts","part","push","number","trim","Number","isInteger","i","length","assignProp","obj","prop","Object","assign","target","path","keys","next","Map","clear","module","exports"],"sources":["C:/Users/lenovo/OneDrive/Documents/local project/platfoorm45_technical_challenge/node_modules/set-value/index.js"],"sourcesContent":["/*!\n * set-value <https://github.com/jonschlinkert/set-value>\n *\n * Copyright (c) Jon Schlinkert (https://github.com/jonschlinkert).\n * Released under the MIT License.\n */\n\n'use strict';\n\nconst { deleteProperty } = Reflect;\nconst isPrimitive = require('is-primitive');\nconst isPlainObject = require('is-plain-object');\n\nconst isObject = value => {\n  return (typeof value === 'object' && value !== null) || typeof value === 'function';\n};\n\nconst isUnsafeKey = key => {\n  return key === '__proto__' || key === 'constructor' || key === 'prototype';\n};\n\nconst validateKey = key => {\n  if (!isPrimitive(key)) {\n    throw new TypeError('Object keys must be strings or symbols');\n  }\n\n  if (isUnsafeKey(key)) {\n    throw new Error(`Cannot set unsafe key: \"${key}\"`);\n  }\n};\n\nconst toStringKey = input => {\n  return Array.isArray(input) ? input.flat().map(String).join(',') : input;\n};\n\nconst createMemoKey = (input, options) => {\n  if (typeof input !== 'string' || !options) return input;\n  let key = input + ';';\n  if (options.arrays !== undefined) key += `arrays=${options.arrays};`;\n  if (options.separator !== undefined) key += `separator=${options.separator};`;\n  if (options.split !== undefined) key += `split=${options.split};`;\n  if (options.merge !== undefined) key += `merge=${options.merge};`;\n  if (options.preservePaths !== undefined) key += `preservePaths=${options.preservePaths};`;\n  return key;\n};\n\nconst memoize = (input, options, fn) => {\n  const key = toStringKey(options ? createMemoKey(input, options) : input);\n  validateKey(key);\n\n  const value = setValue.cache.get(key) || fn();\n  setValue.cache.set(key, value);\n  return value;\n};\n\nconst splitString = (input, options = {}) => {\n  const sep = options.separator || '.';\n  const preserve = sep === '/' ? false : options.preservePaths;\n\n  if (typeof input === 'string' && preserve !== false && /\\//.test(input)) {\n    return [input];\n  }\n\n  const parts = [];\n  let part = '';\n\n  const push = part => {\n    let number;\n    if (part.trim() !== '' && Number.isInteger((number = Number(part)))) {\n      parts.push(number);\n    } else {\n      parts.push(part);\n    }\n  };\n\n  for (let i = 0; i < input.length; i++) {\n    const value = input[i];\n\n    if (value === '\\\\') {\n      part += input[++i];\n      continue;\n    }\n\n    if (value === sep) {\n      push(part);\n      part = '';\n      continue;\n    }\n\n    part += value;\n  }\n\n  if (part) {\n    push(part);\n  }\n\n  return parts;\n};\n\nconst split = (input, options) => {\n  if (options && typeof options.split === 'function') return options.split(input);\n  if (typeof input === 'symbol') return [input];\n  if (Array.isArray(input)) return input;\n  return memoize(input, options, () => splitString(input, options));\n};\n\nconst assignProp = (obj, prop, value, options) => {\n  validateKey(prop);\n\n  // Delete property when \"value\" is undefined\n  if (value === undefined) {\n    deleteProperty(obj, prop);\n\n  } else if (options && options.merge) {\n    const merge = options.merge === 'function' ? options.merge : Object.assign;\n\n    // Only merge plain objects\n    if (merge && isPlainObject(obj[prop]) && isPlainObject(value)) {\n      obj[prop] = merge(obj[prop], value);\n    } else {\n      obj[prop] = value;\n    }\n\n  } else {\n    obj[prop] = value;\n  }\n\n  return obj;\n};\n\nconst setValue = (target, path, value, options) => {\n  if (!path || !isObject(target)) return target;\n\n  const keys = split(path, options);\n  let obj = target;\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const next = keys[i + 1];\n\n    validateKey(key);\n\n    if (next === undefined) {\n      assignProp(obj, key, value, options);\n      break;\n    }\n\n    if (typeof next === 'number' && !Array.isArray(obj[key])) {\n      obj = obj[key] = [];\n      continue;\n    }\n\n    if (!isObject(obj[key])) {\n      obj[key] = {};\n    }\n\n    obj = obj[key];\n  }\n\n  return target;\n};\n\nsetValue.split = split;\nsetValue.cache = new Map();\nsetValue.clear = () => {\n  setValue.cache = new Map();\n};\n\nmodule.exports = setValue;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}